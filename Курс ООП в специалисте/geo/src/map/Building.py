#!/usr/bin/python3
#-*- coding: utf-8 -*-

# если встречается контур building
# то это не контур, а здание

from contextlib import suppress
from .Way import Way

class Building( Way ):    # здание - тоже контур
    
    # чтобы создать экземпляр производного класса, нужно сделать то же, что и при создании экземпляра базового, и может быть что-то еще.
    # чтоб сделать то же самое, нужно вызвать конструктор базового класса
    def __init__( self , xml_el , tags ):
        with suppress( KeyError ) :          # эквивалент эксепт: пасс. супресс просто проглатывает исключения указанных типов
            self.__Levels = int(tags.pop('building:levels'))
            
        super().__init__( xml_el , tags )   # супер - то же, что и селф, но он забывает, какого класса он экземпляр и думает, что базового
                                            # можно не вызывать конструктор базового класса, то это большое исключение. должно быть обоснованно.
                                            # обычно вызывают конструктор базового класса, потом делают что-то еще. Но в питоне можно и по-другому.
    
    levels = property( lambda self : self.__Levels )
    
    # вообще, плохо задавать константами параметры
    stroke_color = property( lambda self : (0.3, 0.3, 0.0) )     # войство как в базовом классе, но вычисляется по-другому.
                                                                 # в производном классе некоторое действие делается по-другому,
                                                                 # значит метод один и тот же. но функция и метод в данном случае - не одно и то же.
                                                                 # функция - способ реализации метода. асфальт != дорога.
                                                                 # эта ситуация называется ПОЛИМОРФИЗМ.                                          
    fill_color   = property( lambda self : (0.7, 0.7, 0.4) )
    
    # подмененный метод должен сделать все, что в базовом + что-то еще.
    # у подмененного метода могут быть другие параметры. но это создает технические сложности.
    def draw( self , canvas , origin = 0j , scale = 1.0 ) :
        super().draw(canvas, origin, scale)      # super берет переменную self и заставляет интерпретатор думать, что она базового класса
        Z = 0j
        N = 0
        for z in self.proj:
            Z += z
            N += 1
        Z = ( Z/N - origin ) * scale
        with suppress( AttributeError ) :           # Исключение атрибьютэррор можно подавлять только, если в блоке одна команда. Иначе небезопасно.
            canvas.drawCentredString( Z.real , Z.imag , str(self.levels) )
    
    
    
    
    
    